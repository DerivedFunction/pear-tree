*pear-tree.txt*    A painless, powerful Vim auto-pair plugin

                                  Pear Tree
Contents                                                           *pear-tree*

    1. Introduction ....................... |pear-tree-introduction|
    2. Configuration ...................... |pear-tree-configuration|

==============================================================================
1. Introduction                                       *pear-tree-introduction*

Pear Tree automatically pairs parentheses, quotes, HTML tags, and many other
text items based on a simple-to-define set of rules, and provides pair-wise
deletion, newline expansion, and other usual auto-pair features.

Pear Tree aims to be non-intrusive and does not break Vim's built-in
dot-repeat or undo functionality.

==============================================================================
2. Configuration                                     *pear-tree-configuration*

Variables:

    g:pear_tree_pairs ..................... |g:pear_tree_pairs|
    g:pear_tree_ft_disabled ............... |g:pear_tree_ft_disabled|
    g:pear_tree_smart_openers ............. |g:pear_tree_smart_openers|
    g:pear_tree_smart_closers ............. |g:pear_tree_smart_closers|
    g:pear_tree_smart_backspace ........... |g:pear_tree_smart_backspace|
    g:pear_tree_timeout ................... |g:pear_tree_timeout|

Mappings:

    <Plug>(PearTreeOpener) ................ |<Plug>(PearTreeOpener)|
    <Plug>(PearTreeCloser) ................ |<Plug>(PearTreeCloser)|
    <Plug>(PearTreeBackspace) ............. |<Plug>(PearTreeBackspace)|
    <Plug>(PearTreeExpand) ................ |<Plug>(PearTreeExpand)|
    <Plug>(PearTreeFinishExpansion) ....... |<Plug>(PearTreeFinishExpansion)|
    <Plug>(PearTreeJump) .................. |<Plug>(PearTreeJump)|
    <Plug>(PearTreeExpandOne) ............. |<Plug>(PearTreeExpandOne)|
    <Plug>(PearTreeJNR) ................... |<Plug>(PearTreeJNR)|

------------------------------------------------------------------------------
                                                           *g:pear_tree_pairs*
                                                           *b:pear_tree_pairs*
Type: Dictionary

Default: >
    {
    \   '(': {'closer': ')'},
    \   '[': {'closer': ']'},
    \   '{': {'closer': '}'},
    \   "'": {'closer': "'"},
    \   '"': {'closer': '"'}
    \ }
<
Define the opening strings and the closers with which they are to be
matched. Buffer-local rules take priority over global rules. Define
`b:pear_tree_pairs` in the appropriate file in your ftplugin folder to
override the default rules for certain filetypes.

Each rule in `g:pear_tree_pairs` has the following form: >
    opener_string: {'closer': closer_string, [options ...]}
<
In the rule, `opener_string` is the string that should be typed, and
`closer_string` is the string to be automatically inserted. Both may be any
length and may contain a wildcard (see |pear_tree_wildcards|).

Each rule can also contain options that modify the pairing behavior
(see |pear_tree_rule_options|).

*pear-tree-wildcards*

Pear Tree supports wildcard matching in string pairs. Wildcards are specified
by using an asterisk `*` within the pairs. A wildcard matches user input until
the next explicitly defined character in the opener is entered.

A wildcard in the closer is replaced by the string of characters to which
the wildcard character in the opener was matched. As an example, with
`g:pear_tree_pairs` containing the following rule: >
    '<*>': {'closer': '</*>'}
<Typing `<html>` yields `<html></html>`, `<ul>` yields `<ul></ul>`, etc.

To include a literal asterisk in a rule, you must escape it with a backslash
like `\*`. Similarly, to include a literal backslash in a rule, you must
escape it with another backslash like `\\`.

*pear-tree-rule-options*

A Pear Tree rule includes several options to more finely tune its matching
behavior:

    `not_in`
    Form: `'not_in': [syntax_region, ...]`
    Function: Do not match the opener you are typing in a syntax region
              contained in the list (requires syntax to be enabled).
    Example: `'(': {'closer': ')', 'not_in': ['String', 'Comment']}`

    `not_if`
    Form: `'not_if': [string, ...]`
    Function: Do not match an opener that contains a wildcard if the value of
              that wildcard is contained in the list.
    Example: `'<*>': {'closer': '</*>', 'not_if': ['br', 'meta']}`

    `until`
    Form: `'until': regexp`
    Function: Replace the wildcard character in the closer with the
              wildcard string in the opener only until the regexp pattern is
              matched. See |match()| for valid patterns.
    Example: `'<*>': {'closer': '</*>', 'until': '\W'}`
             Typing `<p class="Foo">` yields `<p class="Foo"></p>`, and not
             `<p class="Foo"></p class="Foo">` because the space after `<p`
             matches the regexp pattern `'\W'`.
    If not set, the value is `'[[:punct:][:space:]]'` (punctuation or space).

------------------------------------------------------------------------------
                                                     *g:pear_tree_ft_disabled*
Type: List

Default: `[]`

Define filetypes for which Pear Tree should not be enabled.

To change the default value, add something like the following to your vimrc:
>
    let g:pear_tree_ft_disabled = ['c', 'python', 'markdown']
<
------------------------------------------------------------------------------
                                                   *g:pear_tree_smart_openers*
                                                   *b:pear_tree_smart_openers*
Type: Number

Default: `0`

If the value is not 0, Pear Tree will attempt to maintain pair balance when
typing a single-character opener instead of always inserting the closer:

                      |   Enabled    |   Disabled   |
        ---------------------------------------------
        |   Start     |  `foo(bar|))`  |  `foo(bar|))`  |
        |   Type (    |  `foo(bar(|))` |  `foo(bar(|)))`|
        |   Result    |  `foo(bar())`  |  `foo(bar()))` |

If enabled, Pear Tree will check if the second parenthesis is balanced. Since
it is not, typing `(` inserts only `(` and not `()`, thereby making both pairs
of parentheses balanced.

To enable, add the following to your vimrc:
>
    let g:pear_tree_smart_openers = 1
<
------------------------------------------------------------------------------
                                                   *g:pear_tree_smart_closers*
                                                   *b:pear_tree_smart_closers*
Type: Number

Default: `0`

If the value is not 0, Pear Tree will attempt to maintain pair balance when
typing a single-character closer instead of always moving the cursor past
the following closer:

                      |   Enabled    |   Disabled   |
        ---------------------------------------------
        |   Start     |  `(foo(bar|)`  |  `(foo(bar|)`  |
        |   Type )    |  `(foo(bar)|)` |  `(foo(bar)|`  |
        |   Result    |  `(foo(bar))`  |  `(foo(bar)`   |

If enabled, Pear Tree will check if the first open parenthesis is balanced.
Since it is not, typing `)` inserts `)` instead of moving the cursor over the
close parenthesis, thereby making both pairs of parentheses balanced.

To enable, add the following to your vimrc:
>
    let g:pear_tree_smart_closers = 1
<
------------------------------------------------------------------------------
                                                 *g:pear_tree_smart_backspace*
                                                 *b:pear_tree_smart_backspace*
Type: Number

Default: `0`

If the value is not 0, |<Plug>(PearTreeBackspace)| will attempt to maintain
pair balance instead of always deleting empty pairs:

        | Backspace # |  Enabled   |  Disabled  |
        -----------------------------------------
        |      1      |  `(foo()|)`  |  `(foo()|)`  |
        |      2      |  `(foo(|)`   |  `(foo(|)`   |
        |      3      |  `(foo|)`    |  `(foo|`     |

If enabled, the first parenthesis remains balanced, while it becomes
erroneously unbalanced at #3 if disabled.

To enable, add the following to your vimrc:
>
    let g:pear_tree_smart_backspace = 1
<
------------------------------------------------------------------------------
                                                         *g:pear_tree_timeout*
                                                         *b:pear_tree_timeout*
Type: Number

Default: `60`

Set a timeout (in milliseconds) for the balance-checking functions used for
smart pairs. A lower value will prevent delays when typing in larger files
while lowering the accuracy of smart pairing functions.

To disable timeouts, set this variable to a value less than or equal to 0.

This feature requires Vim to be compiled with |+reltime| support.

------------------------------------------------------------------------------
                                                      *<Plug>(PearTreeOpener)*
Default: varies

A `<Plug>` mapping is created for each opener in the |b:pear_tree_pairs|
dictionary. The mapping is of the form `<Plug>(PearTreeOpener_x)` where x is
the final character of the opener string. It is used to trigger auto-pairing
behavior for the corresponding opener.

To use a different key mapping to trigger auto-pairing for an opener, add
something like the following to your vimrc:
>
    imap <key> <Plug>(PearTreeOpener_[)
<
------------------------------------------------------------------------------
                                                      *<Plug>(PearTreeCloser)*
Default: varies

A `<Plug>` mapping is created for each single-character closer in the
|b:pear_tree_pairs| dictionary. Each mapping is of the form
`<Plug>(PearTreeCloser_x)` where x is the closer character. It is used to
either insert the closer or move past the closer that follows the cursor.

To use a different key mapping to trigger the Pear Tree functionality for a
closer, add something like the following to your vimrc:
>
    imap <key> <Plug>(PearTreeCloser_])
<
------------------------------------------------------------------------------
                                                   *<Plug>(PearTreeBackspace)*
Default: `<BS>`

If the cursor is between an opener and closer, delete both. Otherwise, act
like a typical backspace.

Usage: `return foo(|)` -> `return foo|`

To change the default mapping, add something like the following to your vimrc:
>
    imap <key> <Plug>(PearTreeBackspace)
<
------------------------------------------------------------------------------
                                                      *<Plug>(PearTreeExpand)*
Default: `<CR>`

If cursor is between an opener and closer, add a new line and prepare to
add the closer on the line following the cursor's new position.

In order to not break the |.| command, the closer is temporarily erased. It
will automatically be added back to the line following the cursor by
|<Plug>(PearTreeFinishExpansion)|

Usage: >
    1  int foo() {|}
<
->
>
    1  int foo() {
    2      |
    3
<
To change the default mapping, add something like the following to your vimrc:
>
    imap <key> <Plug>(PearTreeExpand)
<
------------------------------------------------------------------------------
                                             *<Plug>(PearTreeFinishExpansion)*
Default: `<ESC>`

If |<Plug>(PearTreeExpand)| has been used, add the closers to their proper
positions. After they have been restored, leave insert mode.

Usage: >
    1  int foo() {
    2      |
    3
<
->
>
    1  int foo() {
    2      []
    3  }
<
To change the default mapping, add something like the following to your vimrc:
>
    imap <key> <Plug>(PearTreeFinishExpansion)
<
------------------------------------------------------------------------------
                                                   *<Plug>(PearTreeExpandOne)*
Default: None

If |<Plug>(PearTreeExpand)| has been used multiple times, leading to nested
pairs, add only the innermost closer to its proper position.

Usage: >
    1  <html>
    2      <body>
    3           <p>Type this and go to the next line.</p>
    4           |
    5
<
->
>
    1  <html>
    2      <body>
    3           <p>Type this and go to the next line.</p>
    4      </body>|
    5
<
To set the mapping, add something like the following to your vimrc:
>
    imap <key> <Plug>(PearTreeExpandOne)
<
------------------------------------------------------------------------------
                                                        *<Plug>(PearTreeJump)*
Default: None

If the cursor is before a closer whose opener appears earlier in the text,
move the cursor past the closer.

Usage: >
    1  <p class="Foo">Hello, world!|</p>
<
->
>
    1  <p class="Foo">Hello, world!</p>|
<
To set the mapping, add something like the following to your vimrc:
>
    imap <key> <Plug>(PearTreeJump)
<
------------------------------------------------------------------------------
                                                         *<Plug>(PearTreeJNR)*
Default: None

If the cursor is before a closer whose opener appears earlier in the text,
move the cursor past the closer and insert a newline ("jump 'n return").

Usage: >
    1  <p class="Foo">Hello, world!|</p>
<
->
>
    1  <p class="Foo">Hello, world!</p>
    2  |
<
To set the mapping, add something like the following to your vimrc:
>
    imap <key> <Plug>(PearTreeExpandOne)
<
------------------------------------------------------------------------------

" vim:tw=78:ts=4:sts=4:sw=4:ft=help:norl:
